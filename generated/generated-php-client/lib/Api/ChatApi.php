<?php
/**
 * ChatApi
 * PHP version 7.2
 *
 * @category Class
 * @package  JeedomOpenAI
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * OpenAI API
 *
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.3.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.13.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace JeedomOpenAI\Api;

use GuzzleHttp\Psr7\MultipartStream;
use Http\Client\Common\Plugin\ErrorPlugin;
use Http\Client\Common\Plugin\RedirectPlugin;
use Http\Client\Common\PluginClient;
use Http\Client\Common\PluginClientFactory;
use Http\Client\Exception\HttpException;
use Http\Client\HttpAsyncClient;
use Http\Discovery\HttpAsyncClientDiscovery;
use Http\Discovery\Psr17FactoryDiscovery;
use Http\Discovery\Psr18ClientDiscovery;
use Http\Message\RequestFactory;
use Http\Promise\Promise;
use JeedomOpenAI\ApiException;
use JeedomOpenAI\Configuration;
use JeedomOpenAI\DebugPlugin;
use JeedomOpenAI\HeaderSelector;
use JeedomOpenAI\ObjectSerializer;
use Psr\Http\Client\ClientExceptionInterface;
use Psr\Http\Client\ClientInterface;
use Psr\Http\Message\RequestFactoryInterface;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\StreamFactoryInterface;
use Psr\Http\Message\UriFactoryInterface;
use Psr\Http\Message\UriInterface;
use function sprintf;

/**
 * ChatApi Class Doc Comment
 *
 * @category Class
 * @package  JeedomOpenAI
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ChatApi
{
    /**
     * @var PluginClient
     */
    protected $httpClient;

    /**
     * @var PluginClient
     */
    protected $httpAsyncClient;

    /**
     * @var UriFactoryInterface
     */
    protected $uriFactory;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @var RequestFactoryInterface
     */
    protected $requestFactory;

    /**
     * @var StreamFactoryInterface
     */
    protected $streamFactory;

    public function __construct(
        ?ClientInterface $httpClient = null,
        ?Configuration $config = null,
        ?HttpAsyncClient $httpAsyncClient = null,
        ?UriFactoryInterface $uriFactory = null,
        ?RequestFactoryInterface $requestFactory = null,
        ?StreamFactoryInterface $streamFactory = null,
        ?HeaderSelector $selector = null,
        ?array $plugins = null,
        $hostIndex = 0
    ) {
        $this->config = $config ?? (new Configuration())->setHost('https://api.openai.com/v1');
        $this->requestFactory = $requestFactory ?? Psr17FactoryDiscovery::findRequestFactory();
        $this->streamFactory = $streamFactory ?? Psr17FactoryDiscovery::findStreamFactory();

        $plugins = $plugins ?? [
            new RedirectPlugin(['strict' => true]),
            new ErrorPlugin(),
        ];

        if ($this->config->getDebug()) {
            $plugins[] = new DebugPlugin(fopen($this->config->getDebugFile(), 'ab'));
        }

        $this->httpClient = (new PluginClientFactory())->createClient(
            $httpClient ?? Psr18ClientDiscovery::find(),
            $plugins
        );

        $this->httpAsyncClient = (new PluginClientFactory())->createClient(
            $httpAsyncClient ?? HttpAsyncClientDiscovery::find(),
            $plugins
        );

        $this->uriFactory = $uriFactory ?? Psr17FactoryDiscovery::findUriFactory();

        $this->headerSelector = $selector ?? new HeaderSelector();

        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createChatCompletion
     *
     * **Starting a new project?** We recommend trying [Responses](/docs/api-reference/responses)  to take advantage of the latest OpenAI platform features. Compare [Chat Completions with Responses](/docs/guides/responses-vs-chat-completions?api-mode&#x3D;responses).  ---  Creates a model response for the given chat conversation. Learn more in the [text generation](/docs/guides/text-generation), [vision](/docs/guides/vision), and [audio](/docs/guides/audio) guides.  Parameter support can differ depending on the model used to generate the response, particularly for newer reasoning models. Parameters that are only supported for reasoning models are noted below. For the current state of  unsupported parameters in reasoning models,  [refer to the reasoning guide](/docs/guides/reasoning).
     *
     * @param  \JeedomOpenAI\Model\CreateChatCompletionRequest $create_chat_completion_request create_chat_completion_request (required)
     *
     * @throws \JeedomOpenAI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \JeedomOpenAI\Model\CreateChatCompletionResponse
     */
    public function createChatCompletion($create_chat_completion_request)
    {
        list($response) = $this->createChatCompletionWithHttpInfo($create_chat_completion_request);
        return $response;
    }

    /**
     * Operation createChatCompletionWithHttpInfo
     *
     * **Starting a new project?** We recommend trying [Responses](/docs/api-reference/responses)  to take advantage of the latest OpenAI platform features. Compare [Chat Completions with Responses](/docs/guides/responses-vs-chat-completions?api-mode&#x3D;responses).  ---  Creates a model response for the given chat conversation. Learn more in the [text generation](/docs/guides/text-generation), [vision](/docs/guides/vision), and [audio](/docs/guides/audio) guides.  Parameter support can differ depending on the model used to generate the response, particularly for newer reasoning models. Parameters that are only supported for reasoning models are noted below. For the current state of  unsupported parameters in reasoning models,  [refer to the reasoning guide](/docs/guides/reasoning).
     *
     * @param  \JeedomOpenAI\Model\CreateChatCompletionRequest $create_chat_completion_request (required)
     *
     * @throws \JeedomOpenAI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \JeedomOpenAI\Model\CreateChatCompletionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createChatCompletionWithHttpInfo($create_chat_completion_request)
    {
        $request = $this->createChatCompletionRequest($create_chat_completion_request);

        try {
            try {
                $response = $this->httpClient->sendRequest($request);
            } catch (HttpException $e) {
                $response = $e->getResponse();
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $response->getStatusCode(),
                        (string) $request->getUri()
                    ),
                    $request,
                    $response,
                    $e
                );
            } catch (ClientExceptionInterface $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $request,
                    null,
                    $e
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\JeedomOpenAI\Model\CreateChatCompletionResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\JeedomOpenAI\Model\CreateChatCompletionResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\JeedomOpenAI\Model\CreateChatCompletionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createChatCompletionAsync
     *
     * **Starting a new project?** We recommend trying [Responses](/docs/api-reference/responses)  to take advantage of the latest OpenAI platform features. Compare [Chat Completions with Responses](/docs/guides/responses-vs-chat-completions?api-mode&#x3D;responses).  ---  Creates a model response for the given chat conversation. Learn more in the [text generation](/docs/guides/text-generation), [vision](/docs/guides/vision), and [audio](/docs/guides/audio) guides.  Parameter support can differ depending on the model used to generate the response, particularly for newer reasoning models. Parameters that are only supported for reasoning models are noted below. For the current state of  unsupported parameters in reasoning models,  [refer to the reasoning guide](/docs/guides/reasoning).
     *
     * @param  \JeedomOpenAI\Model\CreateChatCompletionRequest $create_chat_completion_request (required)
     *
     * @throws \InvalidArgumentException
     * @return Promise
     */
    public function createChatCompletionAsync($create_chat_completion_request)
    {
        return $this->createChatCompletionAsyncWithHttpInfo($create_chat_completion_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createChatCompletionAsyncWithHttpInfo
     *
     * **Starting a new project?** We recommend trying [Responses](/docs/api-reference/responses)  to take advantage of the latest OpenAI platform features. Compare [Chat Completions with Responses](/docs/guides/responses-vs-chat-completions?api-mode&#x3D;responses).  ---  Creates a model response for the given chat conversation. Learn more in the [text generation](/docs/guides/text-generation), [vision](/docs/guides/vision), and [audio](/docs/guides/audio) guides.  Parameter support can differ depending on the model used to generate the response, particularly for newer reasoning models. Parameters that are only supported for reasoning models are noted below. For the current state of  unsupported parameters in reasoning models,  [refer to the reasoning guide](/docs/guides/reasoning).
     *
     * @param  \JeedomOpenAI\Model\CreateChatCompletionRequest $create_chat_completion_request (required)
     *
     * @throws \InvalidArgumentException
     * @return Promise
     */
    public function createChatCompletionAsyncWithHttpInfo($create_chat_completion_request)
    {
        $returnType = '\JeedomOpenAI\Model\CreateChatCompletionResponse';
        $request = $this->createChatCompletionRequest($create_chat_completion_request);

        return $this->httpAsyncClient->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (HttpException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $exception->getRequest(),
                        $exception->getResponse(),
                        $exception
                    );
                }
            );
    }

    /**
     * Create request for operation 'createChatCompletion'
     *
     * @param  \JeedomOpenAI\Model\CreateChatCompletionRequest $create_chat_completion_request (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    public function createChatCompletionRequest($create_chat_completion_request)
    {
        // verify the required parameter 'create_chat_completion_request' is set
        if ($create_chat_completion_request === null || (is_array($create_chat_completion_request) && count($create_chat_completion_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_chat_completion_request when calling createChatCompletion'
            );
        }

        $resourcePath = '/chat/completions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = null;
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/event-stream'],
            'application/json',
            $multipart
        );

        // for model (json/xml)
        if (isset($create_chat_completion_request)) {
            if ($this->headerSelector->isJsonMime($headers['Content-Type'])) {
                $httpBody = json_encode(ObjectSerializer::sanitizeForSerialization($create_chat_completion_request));
            } else {
                $httpBody = $create_chat_completion_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($this->headerSelector->isJsonMime($headers['Content-Type'])) {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();

        $uri = $this->createUri($operationHost, $resourcePath, $queryParams);

        return $this->createRequest('POST', $uri, $headers, $httpBody);
    }

    /**
     * Operation deleteChatCompletion
     *
     * Delete a stored chat completion. Only Chat Completions that have been created with the &#x60;store&#x60; parameter set to &#x60;true&#x60; can be deleted.
     *
     * @param  string $completion_id The ID of the chat completion to delete. (required)
     *
     * @throws \JeedomOpenAI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \JeedomOpenAI\Model\ChatCompletionDeleted
     */
    public function deleteChatCompletion($completion_id)
    {
        list($response) = $this->deleteChatCompletionWithHttpInfo($completion_id);
        return $response;
    }

    /**
     * Operation deleteChatCompletionWithHttpInfo
     *
     * Delete a stored chat completion. Only Chat Completions that have been created with the &#x60;store&#x60; parameter set to &#x60;true&#x60; can be deleted.
     *
     * @param  string $completion_id The ID of the chat completion to delete. (required)
     *
     * @throws \JeedomOpenAI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \JeedomOpenAI\Model\ChatCompletionDeleted, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteChatCompletionWithHttpInfo($completion_id)
    {
        $request = $this->deleteChatCompletionRequest($completion_id);

        try {
            try {
                $response = $this->httpClient->sendRequest($request);
            } catch (HttpException $e) {
                $response = $e->getResponse();
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $response->getStatusCode(),
                        (string) $request->getUri()
                    ),
                    $request,
                    $response,
                    $e
                );
            } catch (ClientExceptionInterface $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $request,
                    null,
                    $e
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\JeedomOpenAI\Model\ChatCompletionDeleted',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\JeedomOpenAI\Model\ChatCompletionDeleted',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\JeedomOpenAI\Model\ChatCompletionDeleted',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteChatCompletionAsync
     *
     * Delete a stored chat completion. Only Chat Completions that have been created with the &#x60;store&#x60; parameter set to &#x60;true&#x60; can be deleted.
     *
     * @param  string $completion_id The ID of the chat completion to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return Promise
     */
    public function deleteChatCompletionAsync($completion_id)
    {
        return $this->deleteChatCompletionAsyncWithHttpInfo($completion_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteChatCompletionAsyncWithHttpInfo
     *
     * Delete a stored chat completion. Only Chat Completions that have been created with the &#x60;store&#x60; parameter set to &#x60;true&#x60; can be deleted.
     *
     * @param  string $completion_id The ID of the chat completion to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return Promise
     */
    public function deleteChatCompletionAsyncWithHttpInfo($completion_id)
    {
        $returnType = '\JeedomOpenAI\Model\ChatCompletionDeleted';
        $request = $this->deleteChatCompletionRequest($completion_id);

        return $this->httpAsyncClient->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (HttpException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $exception->getRequest(),
                        $exception->getResponse(),
                        $exception
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteChatCompletion'
     *
     * @param  string $completion_id The ID of the chat completion to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    public function deleteChatCompletionRequest($completion_id)
    {
        // verify the required parameter 'completion_id' is set
        if ($completion_id === null || (is_array($completion_id) && count($completion_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $completion_id when calling deleteChatCompletion'
            );
        }

        $resourcePath = '/chat/completions/{completion_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = null;
        $multipart = false;



        // path params
        if ($completion_id !== null) {
            $resourcePath = str_replace(
                '{' . 'completion_id' . '}',
                ObjectSerializer::toPathValue($completion_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            '',
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($this->headerSelector->isJsonMime($headers['Content-Type'])) {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();

        $uri = $this->createUri($operationHost, $resourcePath, $queryParams);

        return $this->createRequest('DELETE', $uri, $headers, $httpBody);
    }

    /**
     * Operation getChatCompletion
     *
     * Get a stored chat completion. Only Chat Completions that have been created with the &#x60;store&#x60; parameter set to &#x60;true&#x60; will be returned.
     *
     * @param  string $completion_id The ID of the chat completion to retrieve. (required)
     *
     * @throws \JeedomOpenAI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \JeedomOpenAI\Model\CreateChatCompletionResponse
     */
    public function getChatCompletion($completion_id)
    {
        list($response) = $this->getChatCompletionWithHttpInfo($completion_id);
        return $response;
    }

    /**
     * Operation getChatCompletionWithHttpInfo
     *
     * Get a stored chat completion. Only Chat Completions that have been created with the &#x60;store&#x60; parameter set to &#x60;true&#x60; will be returned.
     *
     * @param  string $completion_id The ID of the chat completion to retrieve. (required)
     *
     * @throws \JeedomOpenAI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \JeedomOpenAI\Model\CreateChatCompletionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getChatCompletionWithHttpInfo($completion_id)
    {
        $request = $this->getChatCompletionRequest($completion_id);

        try {
            try {
                $response = $this->httpClient->sendRequest($request);
            } catch (HttpException $e) {
                $response = $e->getResponse();
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $response->getStatusCode(),
                        (string) $request->getUri()
                    ),
                    $request,
                    $response,
                    $e
                );
            } catch (ClientExceptionInterface $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $request,
                    null,
                    $e
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\JeedomOpenAI\Model\CreateChatCompletionResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\JeedomOpenAI\Model\CreateChatCompletionResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\JeedomOpenAI\Model\CreateChatCompletionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getChatCompletionAsync
     *
     * Get a stored chat completion. Only Chat Completions that have been created with the &#x60;store&#x60; parameter set to &#x60;true&#x60; will be returned.
     *
     * @param  string $completion_id The ID of the chat completion to retrieve. (required)
     *
     * @throws \InvalidArgumentException
     * @return Promise
     */
    public function getChatCompletionAsync($completion_id)
    {
        return $this->getChatCompletionAsyncWithHttpInfo($completion_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getChatCompletionAsyncWithHttpInfo
     *
     * Get a stored chat completion. Only Chat Completions that have been created with the &#x60;store&#x60; parameter set to &#x60;true&#x60; will be returned.
     *
     * @param  string $completion_id The ID of the chat completion to retrieve. (required)
     *
     * @throws \InvalidArgumentException
     * @return Promise
     */
    public function getChatCompletionAsyncWithHttpInfo($completion_id)
    {
        $returnType = '\JeedomOpenAI\Model\CreateChatCompletionResponse';
        $request = $this->getChatCompletionRequest($completion_id);

        return $this->httpAsyncClient->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (HttpException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $exception->getRequest(),
                        $exception->getResponse(),
                        $exception
                    );
                }
            );
    }

    /**
     * Create request for operation 'getChatCompletion'
     *
     * @param  string $completion_id The ID of the chat completion to retrieve. (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    public function getChatCompletionRequest($completion_id)
    {
        // verify the required parameter 'completion_id' is set
        if ($completion_id === null || (is_array($completion_id) && count($completion_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $completion_id when calling getChatCompletion'
            );
        }

        $resourcePath = '/chat/completions/{completion_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = null;
        $multipart = false;



        // path params
        if ($completion_id !== null) {
            $resourcePath = str_replace(
                '{' . 'completion_id' . '}',
                ObjectSerializer::toPathValue($completion_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            '',
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($this->headerSelector->isJsonMime($headers['Content-Type'])) {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();

        $uri = $this->createUri($operationHost, $resourcePath, $queryParams);

        return $this->createRequest('GET', $uri, $headers, $httpBody);
    }

    /**
     * Operation getChatCompletionMessages
     *
     * Get the messages in a stored chat completion. Only Chat Completions that have been created with the &#x60;store&#x60; parameter set to &#x60;true&#x60; will be returned.
     *
     * @param  string $completion_id The ID of the chat completion to retrieve messages from. (required)
     * @param  string $after Identifier for the last message from the previous pagination request. (optional)
     * @param  int $limit Number of messages to retrieve. (optional, default to 20)
     * @param  string $order Sort order for messages by timestamp. Use &#x60;asc&#x60; for ascending order or &#x60;desc&#x60; for descending order. Defaults to &#x60;asc&#x60;. (optional, default to 'asc')
     *
     * @throws \JeedomOpenAI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \JeedomOpenAI\Model\ChatCompletionMessageList
     */
    public function getChatCompletionMessages($completion_id, $after = null, $limit = 20, $order = 'asc')
    {
        list($response) = $this->getChatCompletionMessagesWithHttpInfo($completion_id, $after, $limit, $order);
        return $response;
    }

    /**
     * Operation getChatCompletionMessagesWithHttpInfo
     *
     * Get the messages in a stored chat completion. Only Chat Completions that have been created with the &#x60;store&#x60; parameter set to &#x60;true&#x60; will be returned.
     *
     * @param  string $completion_id The ID of the chat completion to retrieve messages from. (required)
     * @param  string $after Identifier for the last message from the previous pagination request. (optional)
     * @param  int $limit Number of messages to retrieve. (optional, default to 20)
     * @param  string $order Sort order for messages by timestamp. Use &#x60;asc&#x60; for ascending order or &#x60;desc&#x60; for descending order. Defaults to &#x60;asc&#x60;. (optional, default to 'asc')
     *
     * @throws \JeedomOpenAI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \JeedomOpenAI\Model\ChatCompletionMessageList, HTTP status code, HTTP response headers (array of strings)
     */
    public function getChatCompletionMessagesWithHttpInfo($completion_id, $after = null, $limit = 20, $order = 'asc')
    {
        $request = $this->getChatCompletionMessagesRequest($completion_id, $after, $limit, $order);

        try {
            try {
                $response = $this->httpClient->sendRequest($request);
            } catch (HttpException $e) {
                $response = $e->getResponse();
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $response->getStatusCode(),
                        (string) $request->getUri()
                    ),
                    $request,
                    $response,
                    $e
                );
            } catch (ClientExceptionInterface $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $request,
                    null,
                    $e
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\JeedomOpenAI\Model\ChatCompletionMessageList',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\JeedomOpenAI\Model\ChatCompletionMessageList',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\JeedomOpenAI\Model\ChatCompletionMessageList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getChatCompletionMessagesAsync
     *
     * Get the messages in a stored chat completion. Only Chat Completions that have been created with the &#x60;store&#x60; parameter set to &#x60;true&#x60; will be returned.
     *
     * @param  string $completion_id The ID of the chat completion to retrieve messages from. (required)
     * @param  string $after Identifier for the last message from the previous pagination request. (optional)
     * @param  int $limit Number of messages to retrieve. (optional, default to 20)
     * @param  string $order Sort order for messages by timestamp. Use &#x60;asc&#x60; for ascending order or &#x60;desc&#x60; for descending order. Defaults to &#x60;asc&#x60;. (optional, default to 'asc')
     *
     * @throws \InvalidArgumentException
     * @return Promise
     */
    public function getChatCompletionMessagesAsync($completion_id, $after = null, $limit = 20, $order = 'asc')
    {
        return $this->getChatCompletionMessagesAsyncWithHttpInfo($completion_id, $after, $limit, $order)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getChatCompletionMessagesAsyncWithHttpInfo
     *
     * Get the messages in a stored chat completion. Only Chat Completions that have been created with the &#x60;store&#x60; parameter set to &#x60;true&#x60; will be returned.
     *
     * @param  string $completion_id The ID of the chat completion to retrieve messages from. (required)
     * @param  string $after Identifier for the last message from the previous pagination request. (optional)
     * @param  int $limit Number of messages to retrieve. (optional, default to 20)
     * @param  string $order Sort order for messages by timestamp. Use &#x60;asc&#x60; for ascending order or &#x60;desc&#x60; for descending order. Defaults to &#x60;asc&#x60;. (optional, default to 'asc')
     *
     * @throws \InvalidArgumentException
     * @return Promise
     */
    public function getChatCompletionMessagesAsyncWithHttpInfo($completion_id, $after = null, $limit = 20, $order = 'asc')
    {
        $returnType = '\JeedomOpenAI\Model\ChatCompletionMessageList';
        $request = $this->getChatCompletionMessagesRequest($completion_id, $after, $limit, $order);

        return $this->httpAsyncClient->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (HttpException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $exception->getRequest(),
                        $exception->getResponse(),
                        $exception
                    );
                }
            );
    }

    /**
     * Create request for operation 'getChatCompletionMessages'
     *
     * @param  string $completion_id The ID of the chat completion to retrieve messages from. (required)
     * @param  string $after Identifier for the last message from the previous pagination request. (optional)
     * @param  int $limit Number of messages to retrieve. (optional, default to 20)
     * @param  string $order Sort order for messages by timestamp. Use &#x60;asc&#x60; for ascending order or &#x60;desc&#x60; for descending order. Defaults to &#x60;asc&#x60;. (optional, default to 'asc')
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    public function getChatCompletionMessagesRequest($completion_id, $after = null, $limit = 20, $order = 'asc')
    {
        // verify the required parameter 'completion_id' is set
        if ($completion_id === null || (is_array($completion_id) && count($completion_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $completion_id when calling getChatCompletionMessages'
            );
        }

        $resourcePath = '/chat/completions/{completion_id}/messages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = null;
        $multipart = false;

        // query params
        if ($after !== null) {
            if('form' === 'form' && is_array($after)) {
                foreach($after as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['after'] = $after;
            }
        }
        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }
        // query params
        if ($order !== null) {
            if('form' === 'form' && is_array($order)) {
                foreach($order as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['order'] = $order;
            }
        }


        // path params
        if ($completion_id !== null) {
            $resourcePath = str_replace(
                '{' . 'completion_id' . '}',
                ObjectSerializer::toPathValue($completion_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            '',
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($this->headerSelector->isJsonMime($headers['Content-Type'])) {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();

        $uri = $this->createUri($operationHost, $resourcePath, $queryParams);

        return $this->createRequest('GET', $uri, $headers, $httpBody);
    }

    /**
     * Operation listChatCompletions
     *
     * List stored Chat Completions. Only Chat Completions that have been stored with the &#x60;store&#x60; parameter set to &#x60;true&#x60; will be returned.
     *
     * @param  string $model The model used to generate the Chat Completions. (optional)
     * @param  array<string,string> $metadata A list of metadata keys to filter the Chat Completions by. Example:  &#x60;metadata[key1]&#x3D;value1&amp;metadata[key2]&#x3D;value2&#x60; (optional)
     * @param  string $after Identifier for the last chat completion from the previous pagination request. (optional)
     * @param  int $limit Number of Chat Completions to retrieve. (optional, default to 20)
     * @param  string $order Sort order for Chat Completions by timestamp. Use &#x60;asc&#x60; for ascending order or &#x60;desc&#x60; for descending order. Defaults to &#x60;asc&#x60;. (optional, default to 'asc')
     *
     * @throws \JeedomOpenAI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \JeedomOpenAI\Model\ChatCompletionList
     */
    public function listChatCompletions($model = null, $metadata = null, $after = null, $limit = 20, $order = 'asc')
    {
        list($response) = $this->listChatCompletionsWithHttpInfo($model, $metadata, $after, $limit, $order);
        return $response;
    }

    /**
     * Operation listChatCompletionsWithHttpInfo
     *
     * List stored Chat Completions. Only Chat Completions that have been stored with the &#x60;store&#x60; parameter set to &#x60;true&#x60; will be returned.
     *
     * @param  string $model The model used to generate the Chat Completions. (optional)
     * @param  array<string,string> $metadata A list of metadata keys to filter the Chat Completions by. Example:  &#x60;metadata[key1]&#x3D;value1&amp;metadata[key2]&#x3D;value2&#x60; (optional)
     * @param  string $after Identifier for the last chat completion from the previous pagination request. (optional)
     * @param  int $limit Number of Chat Completions to retrieve. (optional, default to 20)
     * @param  string $order Sort order for Chat Completions by timestamp. Use &#x60;asc&#x60; for ascending order or &#x60;desc&#x60; for descending order. Defaults to &#x60;asc&#x60;. (optional, default to 'asc')
     *
     * @throws \JeedomOpenAI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \JeedomOpenAI\Model\ChatCompletionList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listChatCompletionsWithHttpInfo($model = null, $metadata = null, $after = null, $limit = 20, $order = 'asc')
    {
        $request = $this->listChatCompletionsRequest($model, $metadata, $after, $limit, $order);

        try {
            try {
                $response = $this->httpClient->sendRequest($request);
            } catch (HttpException $e) {
                $response = $e->getResponse();
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $response->getStatusCode(),
                        (string) $request->getUri()
                    ),
                    $request,
                    $response,
                    $e
                );
            } catch (ClientExceptionInterface $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $request,
                    null,
                    $e
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\JeedomOpenAI\Model\ChatCompletionList',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\JeedomOpenAI\Model\ChatCompletionList',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\JeedomOpenAI\Model\ChatCompletionList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listChatCompletionsAsync
     *
     * List stored Chat Completions. Only Chat Completions that have been stored with the &#x60;store&#x60; parameter set to &#x60;true&#x60; will be returned.
     *
     * @param  string $model The model used to generate the Chat Completions. (optional)
     * @param  array<string,string> $metadata A list of metadata keys to filter the Chat Completions by. Example:  &#x60;metadata[key1]&#x3D;value1&amp;metadata[key2]&#x3D;value2&#x60; (optional)
     * @param  string $after Identifier for the last chat completion from the previous pagination request. (optional)
     * @param  int $limit Number of Chat Completions to retrieve. (optional, default to 20)
     * @param  string $order Sort order for Chat Completions by timestamp. Use &#x60;asc&#x60; for ascending order or &#x60;desc&#x60; for descending order. Defaults to &#x60;asc&#x60;. (optional, default to 'asc')
     *
     * @throws \InvalidArgumentException
     * @return Promise
     */
    public function listChatCompletionsAsync($model = null, $metadata = null, $after = null, $limit = 20, $order = 'asc')
    {
        return $this->listChatCompletionsAsyncWithHttpInfo($model, $metadata, $after, $limit, $order)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listChatCompletionsAsyncWithHttpInfo
     *
     * List stored Chat Completions. Only Chat Completions that have been stored with the &#x60;store&#x60; parameter set to &#x60;true&#x60; will be returned.
     *
     * @param  string $model The model used to generate the Chat Completions. (optional)
     * @param  array<string,string> $metadata A list of metadata keys to filter the Chat Completions by. Example:  &#x60;metadata[key1]&#x3D;value1&amp;metadata[key2]&#x3D;value2&#x60; (optional)
     * @param  string $after Identifier for the last chat completion from the previous pagination request. (optional)
     * @param  int $limit Number of Chat Completions to retrieve. (optional, default to 20)
     * @param  string $order Sort order for Chat Completions by timestamp. Use &#x60;asc&#x60; for ascending order or &#x60;desc&#x60; for descending order. Defaults to &#x60;asc&#x60;. (optional, default to 'asc')
     *
     * @throws \InvalidArgumentException
     * @return Promise
     */
    public function listChatCompletionsAsyncWithHttpInfo($model = null, $metadata = null, $after = null, $limit = 20, $order = 'asc')
    {
        $returnType = '\JeedomOpenAI\Model\ChatCompletionList';
        $request = $this->listChatCompletionsRequest($model, $metadata, $after, $limit, $order);

        return $this->httpAsyncClient->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (HttpException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $exception->getRequest(),
                        $exception->getResponse(),
                        $exception
                    );
                }
            );
    }

    /**
     * Create request for operation 'listChatCompletions'
     *
     * @param  string $model The model used to generate the Chat Completions. (optional)
     * @param  array<string,string> $metadata A list of metadata keys to filter the Chat Completions by. Example:  &#x60;metadata[key1]&#x3D;value1&amp;metadata[key2]&#x3D;value2&#x60; (optional)
     * @param  string $after Identifier for the last chat completion from the previous pagination request. (optional)
     * @param  int $limit Number of Chat Completions to retrieve. (optional, default to 20)
     * @param  string $order Sort order for Chat Completions by timestamp. Use &#x60;asc&#x60; for ascending order or &#x60;desc&#x60; for descending order. Defaults to &#x60;asc&#x60;. (optional, default to 'asc')
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    public function listChatCompletionsRequest($model = null, $metadata = null, $after = null, $limit = 20, $order = 'asc')
    {

        $resourcePath = '/chat/completions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = null;
        $multipart = false;

        // query params
        if ($model !== null) {
            if('form' === 'form' && is_array($model)) {
                foreach($model as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['model'] = $model;
            }
        }
        // query params
        if ($metadata !== null) {
            if('form' === 'form' && is_array($metadata)) {
                foreach($metadata as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['metadata'] = $metadata;
            }
        }
        // query params
        if ($after !== null) {
            if('form' === 'form' && is_array($after)) {
                foreach($after as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['after'] = $after;
            }
        }
        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }
        // query params
        if ($order !== null) {
            if('form' === 'form' && is_array($order)) {
                foreach($order as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['order'] = $order;
            }
        }




        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            '',
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($this->headerSelector->isJsonMime($headers['Content-Type'])) {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();

        $uri = $this->createUri($operationHost, $resourcePath, $queryParams);

        return $this->createRequest('GET', $uri, $headers, $httpBody);
    }

    /**
     * Operation updateChatCompletion
     *
     * Modify a stored chat completion. Only Chat Completions that have been created with the &#x60;store&#x60; parameter set to &#x60;true&#x60; can be modified. Currently, the only supported modification is to update the &#x60;metadata&#x60; field.
     *
     * @param  string $completion_id The ID of the chat completion to update. (required)
     * @param  \JeedomOpenAI\Model\UpdateChatCompletionRequest $update_chat_completion_request update_chat_completion_request (required)
     *
     * @throws \JeedomOpenAI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \JeedomOpenAI\Model\CreateChatCompletionResponse
     */
    public function updateChatCompletion($completion_id, $update_chat_completion_request)
    {
        list($response) = $this->updateChatCompletionWithHttpInfo($completion_id, $update_chat_completion_request);
        return $response;
    }

    /**
     * Operation updateChatCompletionWithHttpInfo
     *
     * Modify a stored chat completion. Only Chat Completions that have been created with the &#x60;store&#x60; parameter set to &#x60;true&#x60; can be modified. Currently, the only supported modification is to update the &#x60;metadata&#x60; field.
     *
     * @param  string $completion_id The ID of the chat completion to update. (required)
     * @param  \JeedomOpenAI\Model\UpdateChatCompletionRequest $update_chat_completion_request (required)
     *
     * @throws \JeedomOpenAI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \JeedomOpenAI\Model\CreateChatCompletionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateChatCompletionWithHttpInfo($completion_id, $update_chat_completion_request)
    {
        $request = $this->updateChatCompletionRequest($completion_id, $update_chat_completion_request);

        try {
            try {
                $response = $this->httpClient->sendRequest($request);
            } catch (HttpException $e) {
                $response = $e->getResponse();
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $response->getStatusCode(),
                        (string) $request->getUri()
                    ),
                    $request,
                    $response,
                    $e
                );
            } catch (ClientExceptionInterface $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $request,
                    null,
                    $e
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\JeedomOpenAI\Model\CreateChatCompletionResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\JeedomOpenAI\Model\CreateChatCompletionResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\JeedomOpenAI\Model\CreateChatCompletionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateChatCompletionAsync
     *
     * Modify a stored chat completion. Only Chat Completions that have been created with the &#x60;store&#x60; parameter set to &#x60;true&#x60; can be modified. Currently, the only supported modification is to update the &#x60;metadata&#x60; field.
     *
     * @param  string $completion_id The ID of the chat completion to update. (required)
     * @param  \JeedomOpenAI\Model\UpdateChatCompletionRequest $update_chat_completion_request (required)
     *
     * @throws \InvalidArgumentException
     * @return Promise
     */
    public function updateChatCompletionAsync($completion_id, $update_chat_completion_request)
    {
        return $this->updateChatCompletionAsyncWithHttpInfo($completion_id, $update_chat_completion_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateChatCompletionAsyncWithHttpInfo
     *
     * Modify a stored chat completion. Only Chat Completions that have been created with the &#x60;store&#x60; parameter set to &#x60;true&#x60; can be modified. Currently, the only supported modification is to update the &#x60;metadata&#x60; field.
     *
     * @param  string $completion_id The ID of the chat completion to update. (required)
     * @param  \JeedomOpenAI\Model\UpdateChatCompletionRequest $update_chat_completion_request (required)
     *
     * @throws \InvalidArgumentException
     * @return Promise
     */
    public function updateChatCompletionAsyncWithHttpInfo($completion_id, $update_chat_completion_request)
    {
        $returnType = '\JeedomOpenAI\Model\CreateChatCompletionResponse';
        $request = $this->updateChatCompletionRequest($completion_id, $update_chat_completion_request);

        return $this->httpAsyncClient->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (HttpException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $exception->getRequest(),
                        $exception->getResponse(),
                        $exception
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateChatCompletion'
     *
     * @param  string $completion_id The ID of the chat completion to update. (required)
     * @param  \JeedomOpenAI\Model\UpdateChatCompletionRequest $update_chat_completion_request (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    public function updateChatCompletionRequest($completion_id, $update_chat_completion_request)
    {
        // verify the required parameter 'completion_id' is set
        if ($completion_id === null || (is_array($completion_id) && count($completion_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $completion_id when calling updateChatCompletion'
            );
        }
        // verify the required parameter 'update_chat_completion_request' is set
        if ($update_chat_completion_request === null || (is_array($update_chat_completion_request) && count($update_chat_completion_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_chat_completion_request when calling updateChatCompletion'
            );
        }

        $resourcePath = '/chat/completions/{completion_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = null;
        $multipart = false;



        // path params
        if ($completion_id !== null) {
            $resourcePath = str_replace(
                '{' . 'completion_id' . '}',
                ObjectSerializer::toPathValue($completion_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            'application/json',
            $multipart
        );

        // for model (json/xml)
        if (isset($update_chat_completion_request)) {
            if ($this->headerSelector->isJsonMime($headers['Content-Type'])) {
                $httpBody = json_encode(ObjectSerializer::sanitizeForSerialization($update_chat_completion_request));
            } else {
                $httpBody = $update_chat_completion_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($this->headerSelector->isJsonMime($headers['Content-Type'])) {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();

        $uri = $this->createUri($operationHost, $resourcePath, $queryParams);

        return $this->createRequest('POST', $uri, $headers, $httpBody);
    }


    /**
     * @param string $method
     * @param string|UriInterface $uri
     * @param array $headers
     * @param string|StreamInterface|null $body
     *
     * @return RequestInterface
     */
    protected function createRequest(string $method, $uri, array $headers = [], $body = null): RequestInterface
    {
        if ($this->requestFactory instanceof RequestFactory) {
            return $this->requestFactory->createRequest(
                $method,
                $uri,
                $headers,
                $body
            );
        }

        if (is_string($body) && '' !== $body && null === $this->streamFactory) {
            throw new \RuntimeException('Cannot create request: A stream factory is required to create a request with a non-empty string body.');
        }

        $request = $this->requestFactory->createRequest($method, $uri);

        foreach ($headers as $key => $value) {
            $request = $request->withHeader($key, $value);
        }

        if (null !== $body && '' !== $body) {
            $request = $request->withBody(
                is_string($body) ? $this->streamFactory->createStream($body) : $body
            );
        }

        return $request;
    }

    private function createUri(
        string $operationHost,
        string $resourcePath,
        array $queryParams
    ): UriInterface {
        $parsedUrl = parse_url($operationHost);

        $host = $parsedUrl['host'] ?? null;
        $scheme = $parsedUrl['scheme'] ?? null;
        $basePath = $parsedUrl['path'] ?? null;
        $port = $parsedUrl['port'] ?? null;
        $user = $parsedUrl['user'] ?? null;
        $password = $parsedUrl['pass'] ?? null;

        $uri = $this->uriFactory->createUri($basePath . $resourcePath)
            ->withHost($host)
            ->withScheme($scheme)
            ->withPort($port)
            ->withQuery(ObjectSerializer::buildQuery($queryParams));

        if ($user) {
            $uri = $uri->withUserInfo($user, $password);
        }

        return $uri;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
