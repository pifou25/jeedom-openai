<?php
/**
 * AudioApi
 * PHP version 7.2
 *
 * @category Class
 * @package  JeedomOpenAI
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * OpenAI API
 *
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.3.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.13.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace JeedomOpenAI\Api;

use GuzzleHttp\Psr7\MultipartStream;
use Http\Client\Common\Plugin\ErrorPlugin;
use Http\Client\Common\Plugin\RedirectPlugin;
use Http\Client\Common\PluginClient;
use Http\Client\Common\PluginClientFactory;
use Http\Client\Exception\HttpException;
use Http\Client\HttpAsyncClient;
use Http\Discovery\HttpAsyncClientDiscovery;
use Http\Discovery\Psr17FactoryDiscovery;
use Http\Discovery\Psr18ClientDiscovery;
use Http\Message\RequestFactory;
use Http\Promise\Promise;
use JeedomOpenAI\ApiException;
use JeedomOpenAI\Configuration;
use JeedomOpenAI\DebugPlugin;
use JeedomOpenAI\HeaderSelector;
use JeedomOpenAI\ObjectSerializer;
use Psr\Http\Client\ClientExceptionInterface;
use Psr\Http\Client\ClientInterface;
use Psr\Http\Message\RequestFactoryInterface;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\StreamFactoryInterface;
use Psr\Http\Message\UriFactoryInterface;
use Psr\Http\Message\UriInterface;
use function sprintf;

/**
 * AudioApi Class Doc Comment
 *
 * @category Class
 * @package  JeedomOpenAI
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class AudioApi
{
    /**
     * @var PluginClient
     */
    protected $httpClient;

    /**
     * @var PluginClient
     */
    protected $httpAsyncClient;

    /**
     * @var UriFactoryInterface
     */
    protected $uriFactory;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @var RequestFactoryInterface
     */
    protected $requestFactory;

    /**
     * @var StreamFactoryInterface
     */
    protected $streamFactory;

    public function __construct(
        ?ClientInterface $httpClient = null,
        ?Configuration $config = null,
        ?HttpAsyncClient $httpAsyncClient = null,
        ?UriFactoryInterface $uriFactory = null,
        ?RequestFactoryInterface $requestFactory = null,
        ?StreamFactoryInterface $streamFactory = null,
        ?HeaderSelector $selector = null,
        ?array $plugins = null,
        $hostIndex = 0
    ) {
        $this->config = $config ?? (new Configuration())->setHost('https://api.openai.com/v1');
        $this->requestFactory = $requestFactory ?? Psr17FactoryDiscovery::findRequestFactory();
        $this->streamFactory = $streamFactory ?? Psr17FactoryDiscovery::findStreamFactory();

        $plugins = $plugins ?? [
            new RedirectPlugin(['strict' => true]),
            new ErrorPlugin(),
        ];

        if ($this->config->getDebug()) {
            $plugins[] = new DebugPlugin(fopen($this->config->getDebugFile(), 'ab'));
        }

        $this->httpClient = (new PluginClientFactory())->createClient(
            $httpClient ?? Psr18ClientDiscovery::find(),
            $plugins
        );

        $this->httpAsyncClient = (new PluginClientFactory())->createClient(
            $httpAsyncClient ?? HttpAsyncClientDiscovery::find(),
            $plugins
        );

        $this->uriFactory = $uriFactory ?? Psr17FactoryDiscovery::findUriFactory();

        $this->headerSelector = $selector ?? new HeaderSelector();

        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createSpeech
     *
     * Generates audio from the input text.
     *
     * @param  \JeedomOpenAI\Model\CreateSpeechRequest $create_speech_request create_speech_request (required)
     *
     * @throws \JeedomOpenAI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function createSpeech($create_speech_request)
    {
        list($response) = $this->createSpeechWithHttpInfo($create_speech_request);
        return $response;
    }

    /**
     * Operation createSpeechWithHttpInfo
     *
     * Generates audio from the input text.
     *
     * @param  \JeedomOpenAI\Model\CreateSpeechRequest $create_speech_request (required)
     *
     * @throws \JeedomOpenAI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function createSpeechWithHttpInfo($create_speech_request)
    {
        $request = $this->createSpeechRequest($create_speech_request);

        try {
            try {
                $response = $this->httpClient->sendRequest($request);
            } catch (HttpException $e) {
                $response = $e->getResponse();
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $response->getStatusCode(),
                        (string) $request->getUri()
                    ),
                    $request,
                    $response,
                    $e
                );
            } catch (ClientExceptionInterface $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $request,
                    null,
                    $e
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createSpeechAsync
     *
     * Generates audio from the input text.
     *
     * @param  \JeedomOpenAI\Model\CreateSpeechRequest $create_speech_request (required)
     *
     * @throws \InvalidArgumentException
     * @return Promise
     */
    public function createSpeechAsync($create_speech_request)
    {
        return $this->createSpeechAsyncWithHttpInfo($create_speech_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createSpeechAsyncWithHttpInfo
     *
     * Generates audio from the input text.
     *
     * @param  \JeedomOpenAI\Model\CreateSpeechRequest $create_speech_request (required)
     *
     * @throws \InvalidArgumentException
     * @return Promise
     */
    public function createSpeechAsyncWithHttpInfo($create_speech_request)
    {
        $returnType = '\SplFileObject';
        $request = $this->createSpeechRequest($create_speech_request);

        return $this->httpAsyncClient->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (HttpException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $exception->getRequest(),
                        $exception->getResponse(),
                        $exception
                    );
                }
            );
    }

    /**
     * Create request for operation 'createSpeech'
     *
     * @param  \JeedomOpenAI\Model\CreateSpeechRequest $create_speech_request (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    public function createSpeechRequest($create_speech_request)
    {
        // verify the required parameter 'create_speech_request' is set
        if ($create_speech_request === null || (is_array($create_speech_request) && count($create_speech_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_speech_request when calling createSpeech'
            );
        }

        $resourcePath = '/audio/speech';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = null;
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/octet-stream'],
            'application/json',
            $multipart
        );

        // for model (json/xml)
        if (isset($create_speech_request)) {
            if ($this->headerSelector->isJsonMime($headers['Content-Type'])) {
                $httpBody = json_encode(ObjectSerializer::sanitizeForSerialization($create_speech_request));
            } else {
                $httpBody = $create_speech_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($this->headerSelector->isJsonMime($headers['Content-Type'])) {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();

        $uri = $this->createUri($operationHost, $resourcePath, $queryParams);

        return $this->createRequest('POST', $uri, $headers, $httpBody);
    }

    /**
     * Operation createTranscription
     *
     * Transcribes audio into the input language.
     *
     * @param  \SplFileObject $file The audio file object (not file name) to transcribe, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm. (required)
     * @param  \JeedomOpenAI\Model\CreateTranscriptionRequestModel $model model (required)
     * @param  string $language The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) (e.g. &#x60;en&#x60;) format will improve accuracy and latency. (optional)
     * @param  string $prompt An optional text to guide the model&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text#prompting) should match the audio language. (optional)
     * @param  \JeedomOpenAI\Model\AudioResponseFormat $response_format response_format (optional)
     * @param  float $temperature The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit. (optional, default to 0)
     * @param  \JeedomOpenAI\Model\TranscriptionInclude[] $include Additional information to include in the transcription response.  &#x60;logprobs&#x60; will return the log probabilities of the tokens in the  response to understand the model&#39;s confidence in the transcription.  &#x60;logprobs&#x60; only works with response_format set to &#x60;json&#x60; and only with  the models &#x60;gpt-4o-transcribe&#x60; and &#x60;gpt-4o-mini-transcribe&#x60;. (optional)
     * @param  string[] $timestamp_granularities The timestamp granularities to populate for this transcription. &#x60;response_format&#x60; must be set &#x60;verbose_json&#x60; to use timestamp granularities. Either or both of these options are supported: &#x60;word&#x60;, or &#x60;segment&#x60;. Note: There is no additional latency for segment timestamps, but generating word timestamps incurs additional latency. (optional)
     * @param  bool $stream If set to true, the model response data will be streamed to the client as it is generated using [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format).  See the [Streaming section of the Speech-to-Text guide](/docs/guides/speech-to-text?lang&#x3D;curl#streaming-transcriptions) for more information.  Note: Streaming is not supported for the &#x60;whisper-1&#x60; model and will be ignored. (optional, default to false)
     *
     * @throws \JeedomOpenAI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \JeedomOpenAI\Model\CreateTranscription200Response
     */
    public function createTranscription($file, $model, $language = null, $prompt = null, $response_format = null, $temperature = 0, $include = null, $timestamp_granularities = null, $stream = false)
    {
        list($response) = $this->createTranscriptionWithHttpInfo($file, $model, $language, $prompt, $response_format, $temperature, $include, $timestamp_granularities, $stream);
        return $response;
    }

    /**
     * Operation createTranscriptionWithHttpInfo
     *
     * Transcribes audio into the input language.
     *
     * @param  \SplFileObject $file The audio file object (not file name) to transcribe, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm. (required)
     * @param  \JeedomOpenAI\Model\CreateTranscriptionRequestModel $model (required)
     * @param  string $language The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) (e.g. &#x60;en&#x60;) format will improve accuracy and latency. (optional)
     * @param  string $prompt An optional text to guide the model&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text#prompting) should match the audio language. (optional)
     * @param  \JeedomOpenAI\Model\AudioResponseFormat $response_format (optional)
     * @param  float $temperature The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit. (optional, default to 0)
     * @param  \JeedomOpenAI\Model\TranscriptionInclude[] $include Additional information to include in the transcription response.  &#x60;logprobs&#x60; will return the log probabilities of the tokens in the  response to understand the model&#39;s confidence in the transcription.  &#x60;logprobs&#x60; only works with response_format set to &#x60;json&#x60; and only with  the models &#x60;gpt-4o-transcribe&#x60; and &#x60;gpt-4o-mini-transcribe&#x60;. (optional)
     * @param  string[] $timestamp_granularities The timestamp granularities to populate for this transcription. &#x60;response_format&#x60; must be set &#x60;verbose_json&#x60; to use timestamp granularities. Either or both of these options are supported: &#x60;word&#x60;, or &#x60;segment&#x60;. Note: There is no additional latency for segment timestamps, but generating word timestamps incurs additional latency. (optional)
     * @param  bool $stream If set to true, the model response data will be streamed to the client as it is generated using [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format).  See the [Streaming section of the Speech-to-Text guide](/docs/guides/speech-to-text?lang&#x3D;curl#streaming-transcriptions) for more information.  Note: Streaming is not supported for the &#x60;whisper-1&#x60; model and will be ignored. (optional, default to false)
     *
     * @throws \JeedomOpenAI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \JeedomOpenAI\Model\CreateTranscription200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTranscriptionWithHttpInfo($file, $model, $language = null, $prompt = null, $response_format = null, $temperature = 0, $include = null, $timestamp_granularities = null, $stream = false)
    {
        $request = $this->createTranscriptionRequest($file, $model, $language, $prompt, $response_format, $temperature, $include, $timestamp_granularities, $stream);

        try {
            try {
                $response = $this->httpClient->sendRequest($request);
            } catch (HttpException $e) {
                $response = $e->getResponse();
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $response->getStatusCode(),
                        (string) $request->getUri()
                    ),
                    $request,
                    $response,
                    $e
                );
            } catch (ClientExceptionInterface $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $request,
                    null,
                    $e
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\JeedomOpenAI\Model\CreateTranscription200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\JeedomOpenAI\Model\CreateTranscription200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\JeedomOpenAI\Model\CreateTranscription200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createTranscriptionAsync
     *
     * Transcribes audio into the input language.
     *
     * @param  \SplFileObject $file The audio file object (not file name) to transcribe, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm. (required)
     * @param  \JeedomOpenAI\Model\CreateTranscriptionRequestModel $model (required)
     * @param  string $language The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) (e.g. &#x60;en&#x60;) format will improve accuracy and latency. (optional)
     * @param  string $prompt An optional text to guide the model&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text#prompting) should match the audio language. (optional)
     * @param  \JeedomOpenAI\Model\AudioResponseFormat $response_format (optional)
     * @param  float $temperature The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit. (optional, default to 0)
     * @param  \JeedomOpenAI\Model\TranscriptionInclude[] $include Additional information to include in the transcription response.  &#x60;logprobs&#x60; will return the log probabilities of the tokens in the  response to understand the model&#39;s confidence in the transcription.  &#x60;logprobs&#x60; only works with response_format set to &#x60;json&#x60; and only with  the models &#x60;gpt-4o-transcribe&#x60; and &#x60;gpt-4o-mini-transcribe&#x60;. (optional)
     * @param  string[] $timestamp_granularities The timestamp granularities to populate for this transcription. &#x60;response_format&#x60; must be set &#x60;verbose_json&#x60; to use timestamp granularities. Either or both of these options are supported: &#x60;word&#x60;, or &#x60;segment&#x60;. Note: There is no additional latency for segment timestamps, but generating word timestamps incurs additional latency. (optional)
     * @param  bool $stream If set to true, the model response data will be streamed to the client as it is generated using [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format).  See the [Streaming section of the Speech-to-Text guide](/docs/guides/speech-to-text?lang&#x3D;curl#streaming-transcriptions) for more information.  Note: Streaming is not supported for the &#x60;whisper-1&#x60; model and will be ignored. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return Promise
     */
    public function createTranscriptionAsync($file, $model, $language = null, $prompt = null, $response_format = null, $temperature = 0, $include = null, $timestamp_granularities = null, $stream = false)
    {
        return $this->createTranscriptionAsyncWithHttpInfo($file, $model, $language, $prompt, $response_format, $temperature, $include, $timestamp_granularities, $stream)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTranscriptionAsyncWithHttpInfo
     *
     * Transcribes audio into the input language.
     *
     * @param  \SplFileObject $file The audio file object (not file name) to transcribe, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm. (required)
     * @param  \JeedomOpenAI\Model\CreateTranscriptionRequestModel $model (required)
     * @param  string $language The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) (e.g. &#x60;en&#x60;) format will improve accuracy and latency. (optional)
     * @param  string $prompt An optional text to guide the model&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text#prompting) should match the audio language. (optional)
     * @param  \JeedomOpenAI\Model\AudioResponseFormat $response_format (optional)
     * @param  float $temperature The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit. (optional, default to 0)
     * @param  \JeedomOpenAI\Model\TranscriptionInclude[] $include Additional information to include in the transcription response.  &#x60;logprobs&#x60; will return the log probabilities of the tokens in the  response to understand the model&#39;s confidence in the transcription.  &#x60;logprobs&#x60; only works with response_format set to &#x60;json&#x60; and only with  the models &#x60;gpt-4o-transcribe&#x60; and &#x60;gpt-4o-mini-transcribe&#x60;. (optional)
     * @param  string[] $timestamp_granularities The timestamp granularities to populate for this transcription. &#x60;response_format&#x60; must be set &#x60;verbose_json&#x60; to use timestamp granularities. Either or both of these options are supported: &#x60;word&#x60;, or &#x60;segment&#x60;. Note: There is no additional latency for segment timestamps, but generating word timestamps incurs additional latency. (optional)
     * @param  bool $stream If set to true, the model response data will be streamed to the client as it is generated using [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format).  See the [Streaming section of the Speech-to-Text guide](/docs/guides/speech-to-text?lang&#x3D;curl#streaming-transcriptions) for more information.  Note: Streaming is not supported for the &#x60;whisper-1&#x60; model and will be ignored. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return Promise
     */
    public function createTranscriptionAsyncWithHttpInfo($file, $model, $language = null, $prompt = null, $response_format = null, $temperature = 0, $include = null, $timestamp_granularities = null, $stream = false)
    {
        $returnType = '\JeedomOpenAI\Model\CreateTranscription200Response';
        $request = $this->createTranscriptionRequest($file, $model, $language, $prompt, $response_format, $temperature, $include, $timestamp_granularities, $stream);

        return $this->httpAsyncClient->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (HttpException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $exception->getRequest(),
                        $exception->getResponse(),
                        $exception
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTranscription'
     *
     * @param  \SplFileObject $file The audio file object (not file name) to transcribe, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm. (required)
     * @param  \JeedomOpenAI\Model\CreateTranscriptionRequestModel $model (required)
     * @param  string $language The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) (e.g. &#x60;en&#x60;) format will improve accuracy and latency. (optional)
     * @param  string $prompt An optional text to guide the model&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text#prompting) should match the audio language. (optional)
     * @param  \JeedomOpenAI\Model\AudioResponseFormat $response_format (optional)
     * @param  float $temperature The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit. (optional, default to 0)
     * @param  \JeedomOpenAI\Model\TranscriptionInclude[] $include Additional information to include in the transcription response.  &#x60;logprobs&#x60; will return the log probabilities of the tokens in the  response to understand the model&#39;s confidence in the transcription.  &#x60;logprobs&#x60; only works with response_format set to &#x60;json&#x60; and only with  the models &#x60;gpt-4o-transcribe&#x60; and &#x60;gpt-4o-mini-transcribe&#x60;. (optional)
     * @param  string[] $timestamp_granularities The timestamp granularities to populate for this transcription. &#x60;response_format&#x60; must be set &#x60;verbose_json&#x60; to use timestamp granularities. Either or both of these options are supported: &#x60;word&#x60;, or &#x60;segment&#x60;. Note: There is no additional latency for segment timestamps, but generating word timestamps incurs additional latency. (optional)
     * @param  bool $stream If set to true, the model response data will be streamed to the client as it is generated using [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format).  See the [Streaming section of the Speech-to-Text guide](/docs/guides/speech-to-text?lang&#x3D;curl#streaming-transcriptions) for more information.  Note: Streaming is not supported for the &#x60;whisper-1&#x60; model and will be ignored. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    public function createTranscriptionRequest($file, $model, $language = null, $prompt = null, $response_format = null, $temperature = 0, $include = null, $timestamp_granularities = null, $stream = false)
    {
        // verify the required parameter 'file' is set
        if ($file === null || (is_array($file) && count($file) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file when calling createTranscription'
            );
        }
        // verify the required parameter 'model' is set
        if ($model === null || (is_array($model) && count($model) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $model when calling createTranscription'
            );
        }

        $resourcePath = '/audio/transcriptions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = null;
        $multipart = false;




        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = [];
            $paramFiles = is_array($file) ? $file : [$file];
            foreach ($paramFiles as $paramFile) {
                $formParams['file'][] = \GuzzleHttp\Psr7\try_fopen(
                    ObjectSerializer::toFormValue('file', $paramFile)['file'],
                    'rb'
                );
            }
        }
        // form params
        if ($model !== null) {
            $formParams = array_merge($formParams, ObjectSerializer::toFormValue('model', $model));
        }
        // form params
        if ($language !== null) {
            $formParams = array_merge($formParams, ObjectSerializer::toFormValue('language', $language));
        }
        // form params
        if ($prompt !== null) {
            $formParams = array_merge($formParams, ObjectSerializer::toFormValue('prompt', $prompt));
        }
        // form params
        if ($response_format !== null) {
            $formParams = array_merge($formParams, ObjectSerializer::toFormValue('response_format', $response_format));
        }
        // form params
        if ($temperature !== null) {
            $formParams = array_merge($formParams, ObjectSerializer::toFormValue('temperature', $temperature));
        }
        // form params
        if ($include !== null) {
            $formParams = array_merge($formParams, ObjectSerializer::toFormValue('include[]', $include));
        }
        // form params
        if ($timestamp_granularities !== null) {
            $formParams = array_merge($formParams, ObjectSerializer::toFormValue('timestamp_granularities[]', $timestamp_granularities));
        }
        // form params
        if ($stream !== null) {
            $formParams = array_merge($formParams, ObjectSerializer::toFormValue('stream', $stream));
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/event-stream'],
            'multipart/form-data',
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($this->headerSelector->isJsonMime($headers['Content-Type'])) {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();

        $uri = $this->createUri($operationHost, $resourcePath, $queryParams);

        return $this->createRequest('POST', $uri, $headers, $httpBody);
    }

    /**
     * Operation createTranslation
     *
     * Translates audio into English.
     *
     * @param  \SplFileObject $file The audio file object (not file name) translate, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm. (required)
     * @param  \JeedomOpenAI\Model\CreateTranslationRequestModel $model model (required)
     * @param  string $prompt An optional text to guide the model&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text#prompting) should be in English. (optional)
     * @param  string $response_format The format of the output, in one of these options: &#x60;json&#x60;, &#x60;text&#x60;, &#x60;srt&#x60;, &#x60;verbose_json&#x60;, or &#x60;vtt&#x60;. (optional, default to 'json')
     * @param  float $temperature The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit. (optional, default to 0)
     *
     * @throws \JeedomOpenAI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \JeedomOpenAI\Model\CreateTranslation200Response
     */
    public function createTranslation($file, $model, $prompt = null, $response_format = 'json', $temperature = 0)
    {
        list($response) = $this->createTranslationWithHttpInfo($file, $model, $prompt, $response_format, $temperature);
        return $response;
    }

    /**
     * Operation createTranslationWithHttpInfo
     *
     * Translates audio into English.
     *
     * @param  \SplFileObject $file The audio file object (not file name) translate, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm. (required)
     * @param  \JeedomOpenAI\Model\CreateTranslationRequestModel $model (required)
     * @param  string $prompt An optional text to guide the model&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text#prompting) should be in English. (optional)
     * @param  string $response_format The format of the output, in one of these options: &#x60;json&#x60;, &#x60;text&#x60;, &#x60;srt&#x60;, &#x60;verbose_json&#x60;, or &#x60;vtt&#x60;. (optional, default to 'json')
     * @param  float $temperature The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit. (optional, default to 0)
     *
     * @throws \JeedomOpenAI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \JeedomOpenAI\Model\CreateTranslation200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTranslationWithHttpInfo($file, $model, $prompt = null, $response_format = 'json', $temperature = 0)
    {
        $request = $this->createTranslationRequest($file, $model, $prompt, $response_format, $temperature);

        try {
            try {
                $response = $this->httpClient->sendRequest($request);
            } catch (HttpException $e) {
                $response = $e->getResponse();
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $response->getStatusCode(),
                        (string) $request->getUri()
                    ),
                    $request,
                    $response,
                    $e
                );
            } catch (ClientExceptionInterface $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $request,
                    null,
                    $e
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\JeedomOpenAI\Model\CreateTranslation200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\JeedomOpenAI\Model\CreateTranslation200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\JeedomOpenAI\Model\CreateTranslation200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createTranslationAsync
     *
     * Translates audio into English.
     *
     * @param  \SplFileObject $file The audio file object (not file name) translate, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm. (required)
     * @param  \JeedomOpenAI\Model\CreateTranslationRequestModel $model (required)
     * @param  string $prompt An optional text to guide the model&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text#prompting) should be in English. (optional)
     * @param  string $response_format The format of the output, in one of these options: &#x60;json&#x60;, &#x60;text&#x60;, &#x60;srt&#x60;, &#x60;verbose_json&#x60;, or &#x60;vtt&#x60;. (optional, default to 'json')
     * @param  float $temperature The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit. (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return Promise
     */
    public function createTranslationAsync($file, $model, $prompt = null, $response_format = 'json', $temperature = 0)
    {
        return $this->createTranslationAsyncWithHttpInfo($file, $model, $prompt, $response_format, $temperature)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTranslationAsyncWithHttpInfo
     *
     * Translates audio into English.
     *
     * @param  \SplFileObject $file The audio file object (not file name) translate, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm. (required)
     * @param  \JeedomOpenAI\Model\CreateTranslationRequestModel $model (required)
     * @param  string $prompt An optional text to guide the model&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text#prompting) should be in English. (optional)
     * @param  string $response_format The format of the output, in one of these options: &#x60;json&#x60;, &#x60;text&#x60;, &#x60;srt&#x60;, &#x60;verbose_json&#x60;, or &#x60;vtt&#x60;. (optional, default to 'json')
     * @param  float $temperature The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit. (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return Promise
     */
    public function createTranslationAsyncWithHttpInfo($file, $model, $prompt = null, $response_format = 'json', $temperature = 0)
    {
        $returnType = '\JeedomOpenAI\Model\CreateTranslation200Response';
        $request = $this->createTranslationRequest($file, $model, $prompt, $response_format, $temperature);

        return $this->httpAsyncClient->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (HttpException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $exception->getRequest(),
                        $exception->getResponse(),
                        $exception
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTranslation'
     *
     * @param  \SplFileObject $file The audio file object (not file name) translate, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm. (required)
     * @param  \JeedomOpenAI\Model\CreateTranslationRequestModel $model (required)
     * @param  string $prompt An optional text to guide the model&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text#prompting) should be in English. (optional)
     * @param  string $response_format The format of the output, in one of these options: &#x60;json&#x60;, &#x60;text&#x60;, &#x60;srt&#x60;, &#x60;verbose_json&#x60;, or &#x60;vtt&#x60;. (optional, default to 'json')
     * @param  float $temperature The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit. (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    public function createTranslationRequest($file, $model, $prompt = null, $response_format = 'json', $temperature = 0)
    {
        // verify the required parameter 'file' is set
        if ($file === null || (is_array($file) && count($file) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file when calling createTranslation'
            );
        }
        // verify the required parameter 'model' is set
        if ($model === null || (is_array($model) && count($model) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $model when calling createTranslation'
            );
        }

        $resourcePath = '/audio/translations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = null;
        $multipart = false;




        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = [];
            $paramFiles = is_array($file) ? $file : [$file];
            foreach ($paramFiles as $paramFile) {
                $formParams['file'][] = \GuzzleHttp\Psr7\try_fopen(
                    ObjectSerializer::toFormValue('file', $paramFile)['file'],
                    'rb'
                );
            }
        }
        // form params
        if ($model !== null) {
            $formParams = array_merge($formParams, ObjectSerializer::toFormValue('model', $model));
        }
        // form params
        if ($prompt !== null) {
            $formParams = array_merge($formParams, ObjectSerializer::toFormValue('prompt', $prompt));
        }
        // form params
        if ($response_format !== null) {
            $formParams = array_merge($formParams, ObjectSerializer::toFormValue('response_format', $response_format));
        }
        // form params
        if ($temperature !== null) {
            $formParams = array_merge($formParams, ObjectSerializer::toFormValue('temperature', $temperature));
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            'multipart/form-data',
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($this->headerSelector->isJsonMime($headers['Content-Type'])) {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();

        $uri = $this->createUri($operationHost, $resourcePath, $queryParams);

        return $this->createRequest('POST', $uri, $headers, $httpBody);
    }


    /**
     * @param string $method
     * @param string|UriInterface $uri
     * @param array $headers
     * @param string|StreamInterface|null $body
     *
     * @return RequestInterface
     */
    protected function createRequest(string $method, $uri, array $headers = [], $body = null): RequestInterface
    {
        if ($this->requestFactory instanceof RequestFactory) {
            return $this->requestFactory->createRequest(
                $method,
                $uri,
                $headers,
                $body
            );
        }

        if (is_string($body) && '' !== $body && null === $this->streamFactory) {
            throw new \RuntimeException('Cannot create request: A stream factory is required to create a request with a non-empty string body.');
        }

        $request = $this->requestFactory->createRequest($method, $uri);

        foreach ($headers as $key => $value) {
            $request = $request->withHeader($key, $value);
        }

        if (null !== $body && '' !== $body) {
            $request = $request->withBody(
                is_string($body) ? $this->streamFactory->createStream($body) : $body
            );
        }

        return $request;
    }

    private function createUri(
        string $operationHost,
        string $resourcePath,
        array $queryParams
    ): UriInterface {
        $parsedUrl = parse_url($operationHost);

        $host = $parsedUrl['host'] ?? null;
        $scheme = $parsedUrl['scheme'] ?? null;
        $basePath = $parsedUrl['path'] ?? null;
        $port = $parsedUrl['port'] ?? null;
        $user = $parsedUrl['user'] ?? null;
        $password = $parsedUrl['pass'] ?? null;

        $uri = $this->uriFactory->createUri($basePath . $resourcePath)
            ->withHost($host)
            ->withScheme($scheme)
            ->withPort($port)
            ->withQuery(ObjectSerializer::buildQuery($queryParams));

        if ($user) {
            $uri = $uri->withUserInfo($user, $password);
        }

        return $uri;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
