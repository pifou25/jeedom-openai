<?php
/**
 * CreateModerationResponseResultsInnerCategories
 *
 * PHP version 8.1
 *
 * @category Class
 * @package  JeedomOpenAI
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * OpenAI API
 *
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.3.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.13.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace JeedomOpenAI\Model;

use \ArrayAccess;
use \JeedomOpenAI\ObjectSerializer;

/**
 * CreateModerationResponseResultsInnerCategories Class Doc Comment
 *
 * @category Class
 * @description A list of the categories, and whether they are flagged or not.
 * @package  JeedomOpenAI
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class CreateModerationResponseResultsInnerCategories implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'CreateModerationResponse_results_inner_categories';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'hate' => 'bool',
        'hate_threatening' => 'bool',
        'harassment' => 'bool',
        'harassment_threatening' => 'bool',
        'illicit' => 'bool',
        'illicit_violent' => 'bool',
        'self_harm' => 'bool',
        'self_harm_intent' => 'bool',
        'self_harm_instructions' => 'bool',
        'sexual' => 'bool',
        'sexual_minors' => 'bool',
        'violence' => 'bool',
        'violence_graphic' => 'bool'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'hate' => null,
        'hate_threatening' => null,
        'harassment' => null,
        'harassment_threatening' => null,
        'illicit' => null,
        'illicit_violent' => null,
        'self_harm' => null,
        'self_harm_intent' => null,
        'self_harm_instructions' => null,
        'sexual' => null,
        'sexual_minors' => null,
        'violence' => null,
        'violence_graphic' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'hate' => false,
        'hate_threatening' => false,
        'harassment' => false,
        'harassment_threatening' => false,
        'illicit' => true,
        'illicit_violent' => true,
        'self_harm' => false,
        'self_harm_intent' => false,
        'self_harm_instructions' => false,
        'sexual' => false,
        'sexual_minors' => false,
        'violence' => false,
        'violence_graphic' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'hate' => 'hate',
        'hate_threatening' => 'hate/threatening',
        'harassment' => 'harassment',
        'harassment_threatening' => 'harassment/threatening',
        'illicit' => 'illicit',
        'illicit_violent' => 'illicit/violent',
        'self_harm' => 'self-harm',
        'self_harm_intent' => 'self-harm/intent',
        'self_harm_instructions' => 'self-harm/instructions',
        'sexual' => 'sexual',
        'sexual_minors' => 'sexual/minors',
        'violence' => 'violence',
        'violence_graphic' => 'violence/graphic'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'hate' => 'setHate',
        'hate_threatening' => 'setHateThreatening',
        'harassment' => 'setHarassment',
        'harassment_threatening' => 'setHarassmentThreatening',
        'illicit' => 'setIllicit',
        'illicit_violent' => 'setIllicitViolent',
        'self_harm' => 'setSelfHarm',
        'self_harm_intent' => 'setSelfHarmIntent',
        'self_harm_instructions' => 'setSelfHarmInstructions',
        'sexual' => 'setSexual',
        'sexual_minors' => 'setSexualMinors',
        'violence' => 'setViolence',
        'violence_graphic' => 'setViolenceGraphic'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'hate' => 'getHate',
        'hate_threatening' => 'getHateThreatening',
        'harassment' => 'getHarassment',
        'harassment_threatening' => 'getHarassmentThreatening',
        'illicit' => 'getIllicit',
        'illicit_violent' => 'getIllicitViolent',
        'self_harm' => 'getSelfHarm',
        'self_harm_intent' => 'getSelfHarmIntent',
        'self_harm_instructions' => 'getSelfHarmInstructions',
        'sexual' => 'getSexual',
        'sexual_minors' => 'getSexualMinors',
        'violence' => 'getViolence',
        'violence_graphic' => 'getViolenceGraphic'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }


    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[]|null $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->setIfExists('hate', $data ?? [], null);
        $this->setIfExists('hate_threatening', $data ?? [], null);
        $this->setIfExists('harassment', $data ?? [], null);
        $this->setIfExists('harassment_threatening', $data ?? [], null);
        $this->setIfExists('illicit', $data ?? [], null);
        $this->setIfExists('illicit_violent', $data ?? [], null);
        $this->setIfExists('self_harm', $data ?? [], null);
        $this->setIfExists('self_harm_intent', $data ?? [], null);
        $this->setIfExists('self_harm_instructions', $data ?? [], null);
        $this->setIfExists('sexual', $data ?? [], null);
        $this->setIfExists('sexual_minors', $data ?? [], null);
        $this->setIfExists('violence', $data ?? [], null);
        $this->setIfExists('violence_graphic', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['hate'] === null) {
            $invalidProperties[] = "'hate' can't be null";
        }
        if ($this->container['hate_threatening'] === null) {
            $invalidProperties[] = "'hate_threatening' can't be null";
        }
        if ($this->container['harassment'] === null) {
            $invalidProperties[] = "'harassment' can't be null";
        }
        if ($this->container['harassment_threatening'] === null) {
            $invalidProperties[] = "'harassment_threatening' can't be null";
        }
        if ($this->container['illicit'] === null) {
            $invalidProperties[] = "'illicit' can't be null";
        }
        if ($this->container['illicit_violent'] === null) {
            $invalidProperties[] = "'illicit_violent' can't be null";
        }
        if ($this->container['self_harm'] === null) {
            $invalidProperties[] = "'self_harm' can't be null";
        }
        if ($this->container['self_harm_intent'] === null) {
            $invalidProperties[] = "'self_harm_intent' can't be null";
        }
        if ($this->container['self_harm_instructions'] === null) {
            $invalidProperties[] = "'self_harm_instructions' can't be null";
        }
        if ($this->container['sexual'] === null) {
            $invalidProperties[] = "'sexual' can't be null";
        }
        if ($this->container['sexual_minors'] === null) {
            $invalidProperties[] = "'sexual_minors' can't be null";
        }
        if ($this->container['violence'] === null) {
            $invalidProperties[] = "'violence' can't be null";
        }
        if ($this->container['violence_graphic'] === null) {
            $invalidProperties[] = "'violence_graphic' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets hate
     *
     * @return bool
     */
    public function getHate()
    {
        return $this->container['hate'];
    }

    /**
     * Sets hate
     *
     * @param bool $hate Content that expresses, incites, or promotes hate based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste. Hateful content aimed at non-protected groups (e.g., chess players) is harassment.
     *
     * @return self
     */
    public function setHate($hate)
    {
        if (is_null($hate)) {
            throw new \InvalidArgumentException('non-nullable hate cannot be null');
        }
        $this->container['hate'] = $hate;

        return $this;
    }

    /**
     * Gets hate_threatening
     *
     * @return bool
     */
    public function getHateThreatening()
    {
        return $this->container['hate_threatening'];
    }

    /**
     * Sets hate_threatening
     *
     * @param bool $hate_threatening Hateful content that also includes violence or serious harm towards the targeted group based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste.
     *
     * @return self
     */
    public function setHateThreatening($hate_threatening)
    {
        if (is_null($hate_threatening)) {
            throw new \InvalidArgumentException('non-nullable hate_threatening cannot be null');
        }
        $this->container['hate_threatening'] = $hate_threatening;

        return $this;
    }

    /**
     * Gets harassment
     *
     * @return bool
     */
    public function getHarassment()
    {
        return $this->container['harassment'];
    }

    /**
     * Sets harassment
     *
     * @param bool $harassment Content that expresses, incites, or promotes harassing language towards any target.
     *
     * @return self
     */
    public function setHarassment($harassment)
    {
        if (is_null($harassment)) {
            throw new \InvalidArgumentException('non-nullable harassment cannot be null');
        }
        $this->container['harassment'] = $harassment;

        return $this;
    }

    /**
     * Gets harassment_threatening
     *
     * @return bool
     */
    public function getHarassmentThreatening()
    {
        return $this->container['harassment_threatening'];
    }

    /**
     * Sets harassment_threatening
     *
     * @param bool $harassment_threatening Harassment content that also includes violence or serious harm towards any target.
     *
     * @return self
     */
    public function setHarassmentThreatening($harassment_threatening)
    {
        if (is_null($harassment_threatening)) {
            throw new \InvalidArgumentException('non-nullable harassment_threatening cannot be null');
        }
        $this->container['harassment_threatening'] = $harassment_threatening;

        return $this;
    }

    /**
     * Gets illicit
     *
     * @return bool
     */
    public function getIllicit()
    {
        return $this->container['illicit'];
    }

    /**
     * Sets illicit
     *
     * @param bool $illicit Content that includes instructions or advice that facilitate the planning or execution of wrongdoing, or that gives advice or instruction on how to commit illicit acts. For example, \"how to shoplift\" would fit this category.
     *
     * @return self
     */
    public function setIllicit($illicit)
    {
        if (is_null($illicit)) {
            array_push($this->openAPINullablesSetToNull, 'illicit');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('illicit', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['illicit'] = $illicit;

        return $this;
    }

    /**
     * Gets illicit_violent
     *
     * @return bool
     */
    public function getIllicitViolent()
    {
        return $this->container['illicit_violent'];
    }

    /**
     * Sets illicit_violent
     *
     * @param bool $illicit_violent Content that includes instructions or advice that facilitate the planning or execution of wrongdoing that also includes violence, or that gives advice or instruction on the procurement of any weapon.
     *
     * @return self
     */
    public function setIllicitViolent($illicit_violent)
    {
        if (is_null($illicit_violent)) {
            array_push($this->openAPINullablesSetToNull, 'illicit_violent');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('illicit_violent', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['illicit_violent'] = $illicit_violent;

        return $this;
    }

    /**
     * Gets self_harm
     *
     * @return bool
     */
    public function getSelfHarm()
    {
        return $this->container['self_harm'];
    }

    /**
     * Sets self_harm
     *
     * @param bool $self_harm Content that promotes, encourages, or depicts acts of self-harm, such as suicide, cutting, and eating disorders.
     *
     * @return self
     */
    public function setSelfHarm($self_harm)
    {
        if (is_null($self_harm)) {
            throw new \InvalidArgumentException('non-nullable self_harm cannot be null');
        }
        $this->container['self_harm'] = $self_harm;

        return $this;
    }

    /**
     * Gets self_harm_intent
     *
     * @return bool
     */
    public function getSelfHarmIntent()
    {
        return $this->container['self_harm_intent'];
    }

    /**
     * Sets self_harm_intent
     *
     * @param bool $self_harm_intent Content where the speaker expresses that they are engaging or intend to engage in acts of self-harm, such as suicide, cutting, and eating disorders.
     *
     * @return self
     */
    public function setSelfHarmIntent($self_harm_intent)
    {
        if (is_null($self_harm_intent)) {
            throw new \InvalidArgumentException('non-nullable self_harm_intent cannot be null');
        }
        $this->container['self_harm_intent'] = $self_harm_intent;

        return $this;
    }

    /**
     * Gets self_harm_instructions
     *
     * @return bool
     */
    public function getSelfHarmInstructions()
    {
        return $this->container['self_harm_instructions'];
    }

    /**
     * Sets self_harm_instructions
     *
     * @param bool $self_harm_instructions Content that encourages performing acts of self-harm, such as suicide, cutting, and eating disorders, or that gives instructions or advice on how to commit such acts.
     *
     * @return self
     */
    public function setSelfHarmInstructions($self_harm_instructions)
    {
        if (is_null($self_harm_instructions)) {
            throw new \InvalidArgumentException('non-nullable self_harm_instructions cannot be null');
        }
        $this->container['self_harm_instructions'] = $self_harm_instructions;

        return $this;
    }

    /**
     * Gets sexual
     *
     * @return bool
     */
    public function getSexual()
    {
        return $this->container['sexual'];
    }

    /**
     * Sets sexual
     *
     * @param bool $sexual Content meant to arouse sexual excitement, such as the description of sexual activity, or that promotes sexual services (excluding sex education and wellness).
     *
     * @return self
     */
    public function setSexual($sexual)
    {
        if (is_null($sexual)) {
            throw new \InvalidArgumentException('non-nullable sexual cannot be null');
        }
        $this->container['sexual'] = $sexual;

        return $this;
    }

    /**
     * Gets sexual_minors
     *
     * @return bool
     */
    public function getSexualMinors()
    {
        return $this->container['sexual_minors'];
    }

    /**
     * Sets sexual_minors
     *
     * @param bool $sexual_minors Sexual content that includes an individual who is under 18 years old.
     *
     * @return self
     */
    public function setSexualMinors($sexual_minors)
    {
        if (is_null($sexual_minors)) {
            throw new \InvalidArgumentException('non-nullable sexual_minors cannot be null');
        }
        $this->container['sexual_minors'] = $sexual_minors;

        return $this;
    }

    /**
     * Gets violence
     *
     * @return bool
     */
    public function getViolence()
    {
        return $this->container['violence'];
    }

    /**
     * Sets violence
     *
     * @param bool $violence Content that depicts death, violence, or physical injury.
     *
     * @return self
     */
    public function setViolence($violence)
    {
        if (is_null($violence)) {
            throw new \InvalidArgumentException('non-nullable violence cannot be null');
        }
        $this->container['violence'] = $violence;

        return $this;
    }

    /**
     * Gets violence_graphic
     *
     * @return bool
     */
    public function getViolenceGraphic()
    {
        return $this->container['violence_graphic'];
    }

    /**
     * Sets violence_graphic
     *
     * @param bool $violence_graphic Content that depicts death, violence, or physical injury in graphic detail.
     *
     * @return self
     */
    public function setViolenceGraphic($violence_graphic)
    {
        if (is_null($violence_graphic)) {
            throw new \InvalidArgumentException('non-nullable violence_graphic cannot be null');
        }
        $this->container['violence_graphic'] = $violence_graphic;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


