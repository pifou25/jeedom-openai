<?php
/**
 * RealtimeSessionCreateResponse
 *
 * PHP version 8.1
 *
 * @category Class
 * @package  JeedomOpenAI
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * OpenAI API
 *
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.3.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.13.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace JeedomOpenAI\Model;

use \ArrayAccess;
use \JeedomOpenAI\ObjectSerializer;

/**
 * RealtimeSessionCreateResponse Class Doc Comment
 *
 * @category Class
 * @description A new Realtime session configuration, with an ephermeral key. Default TTL for keys is one minute.
 * @package  JeedomOpenAI
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class RealtimeSessionCreateResponse implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'RealtimeSessionCreateResponse';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'client_secret' => '\JeedomOpenAI\Model\RealtimeSessionCreateResponseClientSecret',
        'modalities' => 'string[]',
        'instructions' => 'string',
        'voice' => '\JeedomOpenAI\Model\VoiceIdsShared',
        'input_audio_format' => 'string',
        'output_audio_format' => 'string',
        'input_audio_transcription' => '\JeedomOpenAI\Model\RealtimeSessionCreateResponseInputAudioTranscription',
        'turn_detection' => '\JeedomOpenAI\Model\RealtimeSessionCreateResponseTurnDetection',
        'tools' => '\JeedomOpenAI\Model\RealtimeResponseCreateParamsToolsInner[]',
        'tool_choice' => 'string',
        'temperature' => 'float',
        'max_response_output_tokens' => '\JeedomOpenAI\Model\RealtimeResponseCreateParamsMaxResponseOutputTokens'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'client_secret' => null,
        'modalities' => null,
        'instructions' => null,
        'voice' => null,
        'input_audio_format' => null,
        'output_audio_format' => null,
        'input_audio_transcription' => null,
        'turn_detection' => null,
        'tools' => null,
        'tool_choice' => null,
        'temperature' => null,
        'max_response_output_tokens' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'client_secret' => false,
        'modalities' => false,
        'instructions' => false,
        'voice' => false,
        'input_audio_format' => false,
        'output_audio_format' => false,
        'input_audio_transcription' => false,
        'turn_detection' => false,
        'tools' => false,
        'tool_choice' => false,
        'temperature' => false,
        'max_response_output_tokens' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'client_secret' => 'client_secret',
        'modalities' => 'modalities',
        'instructions' => 'instructions',
        'voice' => 'voice',
        'input_audio_format' => 'input_audio_format',
        'output_audio_format' => 'output_audio_format',
        'input_audio_transcription' => 'input_audio_transcription',
        'turn_detection' => 'turn_detection',
        'tools' => 'tools',
        'tool_choice' => 'tool_choice',
        'temperature' => 'temperature',
        'max_response_output_tokens' => 'max_response_output_tokens'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'client_secret' => 'setClientSecret',
        'modalities' => 'setModalities',
        'instructions' => 'setInstructions',
        'voice' => 'setVoice',
        'input_audio_format' => 'setInputAudioFormat',
        'output_audio_format' => 'setOutputAudioFormat',
        'input_audio_transcription' => 'setInputAudioTranscription',
        'turn_detection' => 'setTurnDetection',
        'tools' => 'setTools',
        'tool_choice' => 'setToolChoice',
        'temperature' => 'setTemperature',
        'max_response_output_tokens' => 'setMaxResponseOutputTokens'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'client_secret' => 'getClientSecret',
        'modalities' => 'getModalities',
        'instructions' => 'getInstructions',
        'voice' => 'getVoice',
        'input_audio_format' => 'getInputAudioFormat',
        'output_audio_format' => 'getOutputAudioFormat',
        'input_audio_transcription' => 'getInputAudioTranscription',
        'turn_detection' => 'getTurnDetection',
        'tools' => 'getTools',
        'tool_choice' => 'getToolChoice',
        'temperature' => 'getTemperature',
        'max_response_output_tokens' => 'getMaxResponseOutputTokens'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const MODALITIES_TEXT = 'text';
    public const MODALITIES_AUDIO = 'audio';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getModalitiesAllowableValues()
    {
        return [
            self::MODALITIES_TEXT,
            self::MODALITIES_AUDIO,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[]|null $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->setIfExists('client_secret', $data ?? [], null);
        $this->setIfExists('modalities', $data ?? [], null);
        $this->setIfExists('instructions', $data ?? [], null);
        $this->setIfExists('voice', $data ?? [], null);
        $this->setIfExists('input_audio_format', $data ?? [], null);
        $this->setIfExists('output_audio_format', $data ?? [], null);
        $this->setIfExists('input_audio_transcription', $data ?? [], null);
        $this->setIfExists('turn_detection', $data ?? [], null);
        $this->setIfExists('tools', $data ?? [], null);
        $this->setIfExists('tool_choice', $data ?? [], null);
        $this->setIfExists('temperature', $data ?? [], null);
        $this->setIfExists('max_response_output_tokens', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['client_secret'] === null) {
            $invalidProperties[] = "'client_secret' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets client_secret
     *
     * @return \JeedomOpenAI\Model\RealtimeSessionCreateResponseClientSecret
     */
    public function getClientSecret()
    {
        return $this->container['client_secret'];
    }

    /**
     * Sets client_secret
     *
     * @param \JeedomOpenAI\Model\RealtimeSessionCreateResponseClientSecret $client_secret client_secret
     *
     * @return self
     */
    public function setClientSecret($client_secret)
    {
        if (is_null($client_secret)) {
            throw new \InvalidArgumentException('non-nullable client_secret cannot be null');
        }
        $this->container['client_secret'] = $client_secret;

        return $this;
    }

    /**
     * Gets modalities
     *
     * @return string[]|null
     */
    public function getModalities()
    {
        return $this->container['modalities'];
    }

    /**
     * Sets modalities
     *
     * @param string[]|null $modalities The set of modalities the model can respond with. To disable audio, set this to [\"text\"].
     *
     * @return self
     */
    public function setModalities($modalities)
    {
        if (is_null($modalities)) {
            throw new \InvalidArgumentException('non-nullable modalities cannot be null');
        }
        $allowedValues = $this->getModalitiesAllowableValues();
        if (array_diff($modalities, $allowedValues)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'modalities', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['modalities'] = $modalities;

        return $this;
    }

    /**
     * Gets instructions
     *
     * @return string|null
     */
    public function getInstructions()
    {
        return $this->container['instructions'];
    }

    /**
     * Sets instructions
     *
     * @param string|null $instructions The default system instructions (i.e. system message) prepended to model  calls. This field allows the client to guide the model on desired  responses. The model can be instructed on response content and format,  (e.g. \"be extremely succinct\", \"act friendly\", \"here are examples of good  responses\") and on audio behavior (e.g. \"talk quickly\", \"inject emotion  into your voice\", \"laugh frequently\"). The instructions are not guaranteed  to be followed by the model, but they provide guidance to the model on the  desired behavior.  Note that the server sets default instructions which will be used if this  field is not set and are visible in the `session.created` event at the  start of the session.
     *
     * @return self
     */
    public function setInstructions($instructions)
    {
        if (is_null($instructions)) {
            throw new \InvalidArgumentException('non-nullable instructions cannot be null');
        }
        $this->container['instructions'] = $instructions;

        return $this;
    }

    /**
     * Gets voice
     *
     * @return \JeedomOpenAI\Model\VoiceIdsShared|null
     */
    public function getVoice()
    {
        return $this->container['voice'];
    }

    /**
     * Sets voice
     *
     * @param \JeedomOpenAI\Model\VoiceIdsShared|null $voice voice
     *
     * @return self
     */
    public function setVoice($voice)
    {
        if (is_null($voice)) {
            throw new \InvalidArgumentException('non-nullable voice cannot be null');
        }
        $this->container['voice'] = $voice;

        return $this;
    }

    /**
     * Gets input_audio_format
     *
     * @return string|null
     */
    public function getInputAudioFormat()
    {
        return $this->container['input_audio_format'];
    }

    /**
     * Sets input_audio_format
     *
     * @param string|null $input_audio_format The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.
     *
     * @return self
     */
    public function setInputAudioFormat($input_audio_format)
    {
        if (is_null($input_audio_format)) {
            throw new \InvalidArgumentException('non-nullable input_audio_format cannot be null');
        }
        $this->container['input_audio_format'] = $input_audio_format;

        return $this;
    }

    /**
     * Gets output_audio_format
     *
     * @return string|null
     */
    public function getOutputAudioFormat()
    {
        return $this->container['output_audio_format'];
    }

    /**
     * Sets output_audio_format
     *
     * @param string|null $output_audio_format The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.
     *
     * @return self
     */
    public function setOutputAudioFormat($output_audio_format)
    {
        if (is_null($output_audio_format)) {
            throw new \InvalidArgumentException('non-nullable output_audio_format cannot be null');
        }
        $this->container['output_audio_format'] = $output_audio_format;

        return $this;
    }

    /**
     * Gets input_audio_transcription
     *
     * @return \JeedomOpenAI\Model\RealtimeSessionCreateResponseInputAudioTranscription|null
     */
    public function getInputAudioTranscription()
    {
        return $this->container['input_audio_transcription'];
    }

    /**
     * Sets input_audio_transcription
     *
     * @param \JeedomOpenAI\Model\RealtimeSessionCreateResponseInputAudioTranscription|null $input_audio_transcription input_audio_transcription
     *
     * @return self
     */
    public function setInputAudioTranscription($input_audio_transcription)
    {
        if (is_null($input_audio_transcription)) {
            throw new \InvalidArgumentException('non-nullable input_audio_transcription cannot be null');
        }
        $this->container['input_audio_transcription'] = $input_audio_transcription;

        return $this;
    }

    /**
     * Gets turn_detection
     *
     * @return \JeedomOpenAI\Model\RealtimeSessionCreateResponseTurnDetection|null
     */
    public function getTurnDetection()
    {
        return $this->container['turn_detection'];
    }

    /**
     * Sets turn_detection
     *
     * @param \JeedomOpenAI\Model\RealtimeSessionCreateResponseTurnDetection|null $turn_detection turn_detection
     *
     * @return self
     */
    public function setTurnDetection($turn_detection)
    {
        if (is_null($turn_detection)) {
            throw new \InvalidArgumentException('non-nullable turn_detection cannot be null');
        }
        $this->container['turn_detection'] = $turn_detection;

        return $this;
    }

    /**
     * Gets tools
     *
     * @return \JeedomOpenAI\Model\RealtimeResponseCreateParamsToolsInner[]|null
     */
    public function getTools()
    {
        return $this->container['tools'];
    }

    /**
     * Sets tools
     *
     * @param \JeedomOpenAI\Model\RealtimeResponseCreateParamsToolsInner[]|null $tools Tools (functions) available to the model.
     *
     * @return self
     */
    public function setTools($tools)
    {
        if (is_null($tools)) {
            throw new \InvalidArgumentException('non-nullable tools cannot be null');
        }
        $this->container['tools'] = $tools;

        return $this;
    }

    /**
     * Gets tool_choice
     *
     * @return string|null
     */
    public function getToolChoice()
    {
        return $this->container['tool_choice'];
    }

    /**
     * Sets tool_choice
     *
     * @param string|null $tool_choice How the model chooses tools. Options are `auto`, `none`, `required`, or  specify a function.
     *
     * @return self
     */
    public function setToolChoice($tool_choice)
    {
        if (is_null($tool_choice)) {
            throw new \InvalidArgumentException('non-nullable tool_choice cannot be null');
        }
        $this->container['tool_choice'] = $tool_choice;

        return $this;
    }

    /**
     * Gets temperature
     *
     * @return float|null
     */
    public function getTemperature()
    {
        return $this->container['temperature'];
    }

    /**
     * Sets temperature
     *
     * @param float|null $temperature Sampling temperature for the model, limited to [0.6, 1.2]. Defaults to 0.8.
     *
     * @return self
     */
    public function setTemperature($temperature)
    {
        if (is_null($temperature)) {
            throw new \InvalidArgumentException('non-nullable temperature cannot be null');
        }
        $this->container['temperature'] = $temperature;

        return $this;
    }

    /**
     * Gets max_response_output_tokens
     *
     * @return \JeedomOpenAI\Model\RealtimeResponseCreateParamsMaxResponseOutputTokens|null
     */
    public function getMaxResponseOutputTokens()
    {
        return $this->container['max_response_output_tokens'];
    }

    /**
     * Sets max_response_output_tokens
     *
     * @param \JeedomOpenAI\Model\RealtimeResponseCreateParamsMaxResponseOutputTokens|null $max_response_output_tokens max_response_output_tokens
     *
     * @return self
     */
    public function setMaxResponseOutputTokens($max_response_output_tokens)
    {
        if (is_null($max_response_output_tokens)) {
            throw new \InvalidArgumentException('non-nullable max_response_output_tokens cannot be null');
        }
        $this->container['max_response_output_tokens'] = $max_response_output_tokens;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


